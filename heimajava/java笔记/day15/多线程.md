# 并发与并行

并发：指两个或多个事件在同一个时间段内发生。（好比一个人吃两个馒头，每个吃一口，交替吃完）
并行：指两个或多个事件在同一时刻发生（同时发生）。（好比两个人吃两个馒头，同时吃）

**Concurrency** is when two or more tasks can start, run, and complete in overlapping time **periods**.  It doesn't necessarily mean they'll ever both be running **at the same instant**.  For example, *multitasking* on a single-core machine.

**Parallelism** is when tasks *literally* run at the same time, e.g., on a multicore processor.

在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每
一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分
时交替运行的时间是非常短的。
而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，
即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核
CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。

> 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同
> 理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个
> 线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为
> 线程调度。

# 线程与进程

进程：（process），是指计算机中已运行的程序。是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。

线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程
中是可以有多个线程的，这个应用程序也可以称之为多线程程序。

简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程

# 线程调度

## 分时调度

所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。

## 抢占式调度

优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为
抢占式调度。

### 设置线程的优先级

设备管理器里面单击某个进程就可以设置线程优先级

### 抢占式调度详解

大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我
们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是
在同时运行，”感觉这些软件好像在同一时刻运行着“。
实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而
言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是
在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的
使用率更高

# 主线程

执行主（main）方法的线程

单线程程序：Java程序中只有一个线程，执行从main方法开始，从上到下依次执行

jvm执行main方法会进入到栈内存。jvm会找操作系统开辟一条main方法通向cpu的；路径，CPU就可以通过这个路径来执行main方法，而这个路径有一个名字，叫主线程。

# 创建线程类

## 创建多线程程序的第一种方式：创建Thread类的子类

java.lang.Thread类：时描述线程的类，想要实现多线程程序，就要继承这个类。

### 实现步骤

1. 创建一个Thread类的子类；

2. 在子类中重写Thread类的run方法，设置线程任务（开启线程要做什么）

3. 创建子类对象

4. 调用Thread类中的start方法，开启新的线程，执行run方法

	​		void start()使该线程开始执行，Java虚拟机调用该线程的run方法。

	​		结果是两个线程并发的运行，当前线程和另一个线程（创建的新线程，执行其run方法）

	​		多次启动一个线程是非法的，特别当线程已经结束后，不能重新启动。

	因为Java是抢占式调度，哪个线程的优先级高，哪个线程就先执行，如果优先级一样，就随机选择

	```java
	package space.buercheng.java.demo.thread;
	
	public class MyThread extends Thread {
	    @Override
	    public void run() {
	        for (int i = 0; i < 20; i++)
	            System.out.println("MyThread" + i);
	    }
	}
	```

	```java
	package space.buercheng.java.demo.thread;
	
	public class TestThread {
	    public static void main(String[] args) {
	        MyThread mt = new MyThread();
	        mt.start();
	        for (int i = 0; i < 20; i++)
	            System.out.println("main" + i);
	    }
	}
	```

	![image-20200907195054299](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200907195054299.png)

	​							   ![image-20200907195113191](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200907195113191.png)  

## Thread类常用方法

### 获取线程名称

1. 使用Thread类中的getName方法；String getName()：返回该线程的名称
2. 可以先获取到当前正在执行的线程，使用线程中的getName方法返回线程名称：static Thread currentThread()：返回当前正在执行的线程对象的引用。

```java
package space.buercheng.java.demo.thread.methods;

public class MyThread extends Thread{
    @Override
    public void run() {
        //获取线程名称
        String name = getName();
        System.out.println(name);
    }
}

```

```java
package space.buercheng.java.demo.thread.methods;

public class GetThreadName {
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        mt.start();
        //mt.start();错误Exception in thread "main" java.lang.IllegalThreadStateException
        //mt.start();
        new MyThread().start();
        new MyThread().start();
    }
}

```

![image-20200908001710319](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200908001710319.png)

```java
package space.buercheng.java.demo.thread.methods;

public class MyThread extends Thread{
    @Override
    public void run() {
        //获取线程名称
        //String name = getName();
        //System.out.println(name);
        Thread thread = Thread.currentThread();
        System.out.println(thread);
        String name = thread.getName();
        System.out.println(name);
    }
}

```

```java
package space.buercheng.java.demo.thread.methods;

public class GetThreadName {
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        mt.start();
        //mt.start();错误Exception in thread "main" java.lang.IllegalThreadStateException
        //mt.start();
        new MyThread().start();
        new MyThread().start();
    }
}

```

![image-20200908002001697](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200908002001697.png)

### 设置线程名字

1. 使用Thread类中的setName(String name)方法：void setName(String name):更改线程名字，使之与参数name一致

2. 创建一个带参的构造方法，参数传递线程的名字，调用父类的带参构造方法，让父类给子线程一个名字

	

	

	```java
	package space.buercheng.java.demo.thread.methods;
	
	public class MyThread01 extends Thread{
	    @Override
	    public void run() {
	        //获取线程名字
	        String name = Thread.currentThread().getName();
	        System.out.println(name);
	    }
	}
	```

	

```java
package space.buercheng.java.demo.thread.methods;

public class SetThreadName {
    public static void main(String[] args) {
        MyThread01 mt = new MyThread01();
        //设置线程名字
        mt.setName("线程名字");
        mt.start();
    }
}

```

![image-20200909175547356](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200909175547356.png)

```java
package space.buercheng.java.demo.thread.methods;

public class MyThread01 extends Thread{
    public MyThread01() {
    }

    public MyThread01(String name) {
        super(name);
    }

    @Override
    public void run() {
        //获取线程名字
        String name = Thread.currentThread().getName();
        System.out.println(name);
    }
}

```

```java
package space.buercheng.java.demo.thread.methods;

public class SetThreadName {
    public static void main(String[] args) {
        MyThread01 mt = new MyThread01();
        //设置线程名字
        mt.setName("线程名字");
        mt.start();

        MyThread01 mt1 = new MyThread01("第二种设置方法");
        mt1.start();
    }
}

```

![image-20200909175653923](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200909175653923.png)

### sleep方法

```
public static void sleep(long millis) throws InterruptedException
```

```java
package space.buercheng.java.demo.thread.methods;

public class ThreadSleep {
    //调用Thread.sleep(long mills)方法模拟秒表运行
    public static void main(String[] args) {
        for (int i = 1; i <= 60; i++) {
            System.out.println(i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }
}

```

## 创建线程的第二种方法：实现Runnable接口

java.lang.Runnable:接口应该由那些打算通过某一线程来执行其实例的类来实现。类必须定义一个run的无参方法。

java.lang.Thread类的构造方法:Thread(Runnable target):分配新的Thread对象；Thread(Runnable target,String name):分配新的Thread对象。

1. 创建一个Runnable接口的实现类；
2. 在Runnable实现类中重写run方法；
3. 创建一个Runnable实现类的对象；
4. 创建Thread类对象，构造方法传递Runnable实现类对象；
5. 调用Thread类的start方法，开启新的线程执行方法。

```java
package space.buercheng.java.demo02;

public class RunnableImpl implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println(Thread.currentThread().getName() + "---->" + i);
        }
    }
}

```

```java
package space.buercheng.java.demo02;

public class TestThread {
    public static void main(String[] args) {
        RunnableImpl run = new RunnableImpl();
        Thread t = new Thread(run);
        t.start();
        for (int i = 0; i < 20; i++) {
            System.out.println(Thread.currentThread().getName() + "---->" + i);
        }
    }
}

```

## 实现Runnable接口创建多线程的好处

避免了单继承的局限性：一个类只能继承一个类，继承了Thread类就不能再继承其他类；实现Runnable接口，还能继承其他类，实现其他接口。

增强了程序的扩展性，降低了程序的耦合性：实现Runnable接口的方式，将设置线程任务和启动线程进行了分离（解耦）---实现类中，重写了run方法，用来设置线程任务；创建Thread类对象，调用start方法来启动线程。

## 匿名内部类的方式实现多线程的创建

匿名内部类作用：简化代码，把子类继承父类，重写父类的方法，创建子类对象合一步完成，把实现类实现类接口，重写接口中的方法，创建实现类对象合一步完成

匿名内部类最终产物：子类/实现类对象，而这个类没有名字

格式：

​	new 父类/接口(){

重复父类方法

}；

```java
package space.buercheng.java.demo03;

public class AnonymousThread {
    public static void main(String[] args) {
        //类
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println("匿名内部类实现多线程 " + Thread.currentThread().getName());
                }
            }
        }.start();
        //接口
        Runnable r = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println("接口简化：匿名内部类实现多线程 " + Thread.currentThread().getName());
                }
            }
        };
        new Thread(r).start();

        //简化接口
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println("接口：匿名内部类实现多线程 " + Thread.currentThread().getName());
                }
            }
        }).start();
    }
}

```

![image-20200910022326132](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200910022326132.png)

