# 异常概念

异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：

* **异常** ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。

在Java等面向对象的编程语言中，**异常本身是一个类**，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是**中断处理**。

> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.

# 异常体系

![image-20200826082901746](%E5%BC%82%E5%B8%B8.assets/image-20200826082901746.png)

异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。

* **Error**:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。必须修改源代码，程序才能运行

* **Exception**:编译期异常，进行编译（写代码）时Java程序出现的问题

	​					RuntimeException：运行期异常，Java程序运行过程中出现的异常。

	​					异常处理掉，程序可以继续运行

## Exception

```java
package space.buercheng.java.demo01;

import java.text.SimpleDateFormat;
import java.util.Date;

public class Summary {
    public static void main(String[] args) {
        //Exception:编译期异常，进行编译（写代码）时出现的异常
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");//用来格式化日期
        Date date = sdf.parse("2020-08-26");
    }
}
```

![image-20200826090630391](%E5%BC%82%E5%B8%B8.assets/image-20200826090630391.png)

可以看到报未处理异常，可以采用两种方式处理异常：

1.throws异常，交给虚拟机处理----中断异常，程序不会继续执行

```java
package space.buercheng.java.demo01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Summary {
    public static void main(String[] args) throws ParseException {
        //Exception:编译期异常，进行编译（写代码）时出现的异常
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");//用来格式化日期
        Date date = sdf.parse("2020-08-26");
        System.out.println("后续代码");
    }
}

```

未发生异常时，正常运行。发生异常时：

```
package space.buercheng.java.demo01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Summary {
    public static void main(String[] args) throws ParseException {
        //Exception:编译期异常，进行编译（写代码）时出现的异常
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");//用来格式化日期
        Date date = sdf.parse("20200826");//格式与指定格式不同，会发生ParesException 解析异常
        System.out.println("后续代码");
    }
}

```

后续代码不会继续执行

![image-20200826091711389](%E5%BC%82%E5%B8%B8.assets/image-20200826091711389.png)

2.try-catch---异常处理后，程序会继续运行

```java
package space.buercheng.java.demo01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Summary {
    public static void main(String[] args) {
        //Exception:编译期异常，进行编译（写代码）时出现的异常
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");//用来格式化日期
        try {
            Date date = sdf.parse("2020-08-26");
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
}

```

发生异常代码：

```java
package space.buercheng.java.demo01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Summary {
    public static void main(String[] args) {
        //Exception:编译期异常，进行编译（写代码）时出现的异常
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");//用来格式化日期
        try {
            Date date = sdf.parse("20200826");
        } catch (ParseException e) {
            e.printStackTrace();
        }
        System.out.println("后续代码");
    }
}

```

后续代码会执行：

![image-20200826095623086](%E5%BC%82%E5%B8%B8.assets/image-20200826095623086.png)

## RuntimeException

```java
package space.buercheng.java.demo01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Summary {
    public static void main(String[] args) {
        int[] arr = new int[]{1,2,3};
        System.out.println(arr[3]);
    }
}

```

![image-20200826095950775](%E5%BC%82%E5%B8%B8.assets/image-20200826095950775.png)

编译时未报异常信息

运行后报ArrayIndexOutOfBoundsException异常

![image-20200826100141952](%E5%BC%82%E5%B8%B8.assets/image-20200826100141952.png)

## Error

```java
package space.buercheng.java.demo01;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Summary {
    public static void main(String[] args) {
        int[] arr = new int[1024*1024*1024];
    }
}
```

![image-20200826102436545](%E5%BC%82%E5%B8%B8.assets/image-20200826102436545.png)

# 异常产生的过程



# 异常的处理

Java异常处理的五个关键字：try，catch,throw,throws,finally

## throw关键字

可以使用他在**指定的方法中**抛出指定的异常

使用格式：throw new xxxException("异常产生的原因");

注意：1.必须写在方法内部

​			2.throw后new的对象必须是Exception或者Exception的子类

​			3.throw关键字抛出指定的异常对象，我们就必须处理这个异常

​				1）throw关键字后边创建的时RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给jvm（打印异常对想，中断程序）

​			    2）throw后边创建的是编译异常，（写代码时报错，），我们必须处理这个异常，要么throws，要么try-catch

我们必须对方法传递过来的参数进行合法性校验，如果参数不合法，我们必须使用抛出异常的方式，告诉方法调用者，传递的参数有问题。

```java
package space.buercheng.java.demo01;

public class TestThrow {
    public static void main(String[] args) {
        int[] arr = null;
        int e =getElement(arr,0);
        System.out.println(e);
    }

    /**
     * 定义一个方法，获取指定索引的元素
     * 参数： int[] arr,int index
     * */
    public static int getElement(int[] arr, int index) {
        /**
         * 对数组传递过来的参数数组进行合法性校验
         *如果arr的值是null。我们就抛出NullPointException
         * 告诉方法调用者，传递的数组值是null
         * */
        if(arr == null){
            throw new NullPointerException("传递的数组值是null");
        }
        return arr[index];
    }
}

```

![image-20200826111313045](%E5%BC%82%E5%B8%B8.assets/image-20200826111313045.png)

注意：NullPointException是一个运行期异常，我们不用处理，默认交给jvm

```
package space.buercheng.java.demo01;

public class TestThrow {
    public static void main(String[] args) {
        int[] arr = new int[3];
        int e =getElement(arr,3);
        System.out.println(e);
    }

    /**
     * 定义一个方法，获取指定索引的元素
     * 参数： int[] arr,int index
     * */
    public static int getElement(int[] arr, int index) {
        /**
         * 对数组传递过来的参数数组进行合法性校验
         *如果arr的值是null。我们就抛出NullPointException
         * 告诉方法调用者，传递的数组值是null
         * */
        if(arr == null){
            throw new NullPointerException("传递的数组值是null");
        }
        /**
         * 我们可以对传递过来的参数index进行合法性校验
         * 如果index的范围不在数组的索引范围，就抛出ArrayIndexOutOfBoundsException异常
         * **/
        if(index < 0 || index > arr.length){
            throw new ArrayIndexOutOfBoundsException("索引超过数组大小");
        }
        return arr[index];
    }
}

```

![深度截图_选择区域_20200826134055](%E5%BC%82%E5%B8%B8.assets/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20200826134055.png)

ArrayIndexOutOfBoundsException是一个运行期异常，我们不用处理，默认交给jvm

# Objects非空判断---requireNonNull方法

还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。

* `public static <T> T requireNonNull(T obj)`:查看指定引用对象不是null。

查看源码发现这里对为null的进行了抛出异常操作：

~~~java
public static <T> T requireNonNull(T obj) {
    if (obj == null)
      	throw new NullPointerException();
    return obj;
}
~~~

```java
package space.buercheng.java.demo01;

import java.util.Objects;

public class RequireNull {
    public static void main(String[] args) {
        String[] st = null;
        method(st);
    }
    public static void method(Object obj){
        //校验传入参数合法性，调用Objects的requireNonNull判断传入参数是否为空，如果为空，则报空指针异常
        Objects.requireNonNull(obj);
    }
}

```

![image-20200826141502733](%E5%BC%82%E5%B8%B8.assets/image-20200826141502733.png)

# 声明异常throws

throws关键字：异常处理的第一种方式，交给别人处理。

作用：当方法内部抛出异常对象的时候，那么我们必须处理这个异常对象，可以使用throws关键字来处理异常对象，使用后会把异常对象声明抛出给方法的调用者，自己不处理，给别人处理，最终交给JVM处理---中断处理

使用格式：在方法声明时使用

​					修饰符 返回值类型 方法名（参数列表） throws someExceptions{

​											throw new AAAException（"产生的原因"）；

​											throw new BBBException（"产生的原因"）；

​											...

​					}

注意：

1. throws关键字必须写在方法声明处
2. throws后面声明的异常必须是Exception或Exception的子类
3. 方法内部如果抛出了多个异常，throws后面就必须声明多个异常；如果抛出的异常存在父子关系，则只要声明父类异常即可
4. 调用了一个声明抛出异常的方法，我们就必须处理声明的异常。1）要么继续使用throws声明抛出异常，交给方法的调用者，最终交给JVM处理   2）要么使用try-catch语句处理



```java
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;

public class TestThrows {
    public static void main(String[] args) throws FileNotFoundException{//throws 交给jvm处理异常
        String path = "D:\\a.txt";
        getFile(path);//编译期异常，必须处理，可以交给方法调用者处理,继续throws
    }
    /**
     * 定义一个方法：对传入的文件的路径进行合法性判断
     * 如果路径不是C:\\a.txt则抛出文件找不到FileNotFoundException异常对象，通知给方法调用者
     * 注意：FileNotFoundException是编译期异常，抛出了异常就必须处理
     * 我们可以继续声明抛出异常对象，让方法的调用者处理
     * */
    public static void getFile(String path) throws FileNotFoundException{//交给方法调用者处理该异常
        if(!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
    }
}

```

![image-20200826164700679](%E5%BC%82%E5%B8%B8.assets/image-20200826164700679.png)

存在多个异常就可以声明多个异常

```java
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;
import java.io.IOException;

public class TestThrows {
    public static void main(String[] args) throws FileNotFoundException, IOException {//throws 交给jvm处理异常
        String path = "c:\\a.exe";
        getFile(path);//编译期异常，必须处理，可以交给方法调用者处理,继续throws
    }

    /**
     * 定义一个方法：对传入的文件的路径以及文件的后缀进行合法性判断
     * 如果路径不是C:\\a.txt则抛出文件找不到FileNotFoundException异常对象，通知给方法调用者
     * 注意：FileNotFoundException是编译期异常，抛出了异常就必须处理
     * 如果后缀不是.txt抛出IOException
     * 我们可以继续声明抛出异常对象，让方法的调用者处理，同时用throws声明FileNotFound和IOException
     */
    public static void getFile(String path) throws FileNotFoundException, IOException {//交给方法调用者处理该异常
        if (!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
        if (!path.endsWith(".txt"))
            throw new IOException("文件扩展名不为.txt");
    }
}

```

IOException是FileNotFound的父类，所以可以只声明父类即可

```
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;
import java.io.IOException;

public class TestThrows {
    public static void main(String[] args) throws IOException {//throws 交给jvm处理异常
        String path = "c:\\a.exe";
        getFile(path);//编译期异常，必须处理，可以交给方法调用者处理,继续throws
    }

    /**
     * 定义一个方法：对传入的文件的路径以及文件的后缀进行合法性判断
     * 如果路径不是C:\\a.txt则抛出文件找不到FileNotFoundException异常对象，通知给方法调用者
     * 注意：FileNotFoundException是编译期异常，抛出了异常就必须处理
     * 如果后缀不是.txt抛出IOException
     * 我们可以继续声明抛出异常对象，让方法的调用者处理，同时用throws声明FileNotFound和IOException
     */
    public static void getFile(String path) throws IOException {//交给方法调用者处理该异常
        if (!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
        if (!path.endsWith(".txt"))
            throw new IOException("文件扩展名不为.txt");
    }
}

```

![image-20200826165457902](%E5%BC%82%E5%B8%B8.assets/image-20200826165457902.png)

# 捕获异常try-catch

如果异常出现的话,会立刻终止程序,所以我们得处理异常:

1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。
2. 在方法中使用try-catch的语句块来处理异常。

try-catch:异常处理的第二种方式，自己处理异常

格式：

```java
try{
	可能产生异常的代码
}catch(定义一个异常的变量，用来接收try中抛出的异常对象){
	异常的处理逻辑，产生异常对象后，怎么处理异常对象
	一般会把异常信息记录到日志中
}//可以有多个catch。抛出多个异常时，catch多个异常
...
catch{
...
}
```

注意：

1. try中可能会出现多个异常对象，那么就可以使用多个catch来处理这些异常对象
2. 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑后，会继续执行try-catch语句块后的内容；如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，继续执行try-catch后的内容

```java
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;
import java.io.IOException;

public class TestTryCatch {
    public static void main(String[] args) {
        String path = "c:\\a.tx";
        try {
            getFile(path);
        } catch (IOException e) {
            System.out.println(e);
        }
        System.out.println("后续代码");
    }
    public static void getFile(String path) throws IOException {//交给方法调用者处理该异常
        if (!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
        if (!path.endsWith(".txt"))
            throw new IOException("文件扩展名不为.txt");
    }
}

```

![image-20200826174054030](%E5%BC%82%E5%B8%B8.assets/image-20200826174054030.png)

## 如何获取异常信息

Throwable类中定义了一些查看方法:

* `public String getMessage()`:返回此throwable的简短描述。


* `public String toString()`:返回此throwable的详细消息字符串。重写了Object的toString方法，与直接打印异常对象的输出一致
* `public void printStackTrace()`:JVM打印异常对象，默认此方法，打印的异常信息是最全面的。

​            *包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。

```java
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;
import java.io.IOException;

public class TestThrowableMethods {
    public static void main(String[] args) {
        String path = "c:\\a.tx";
        try {
            getFile(path);
        } catch (IOException e) {
            System.out.println( e.getMessage());//文件找不到
        }
        System.out.println("后续代码");
    }
    public static void getFile(String path) throws IOException {//交给方法调用者处理该异常
        if (!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
        if (!path.endsWith(".txt"))
            throw new IOException("文件扩展名不为.txt");
    }
}

```

![image-20200826174915330](%E5%BC%82%E5%B8%B8.assets/image-20200826174915330.png)

```java
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;
import java.io.IOException;

public class TestThrowableMethods {
    public static void main(String[] args) {
        String path = "c:\\a.tx";
        try {
            getFile(path);
        } catch (IOException e) {
            //System.out.println( e.getMessage());//文件找不到
            System.out.println(e.toString());//java.io.FileNotFoundException: 文件找不到
            System.out.println(e);
        }
        System.out.println("后续代码");
    }
    public static void getFile(String path) throws IOException {//交给方法调用者处理该异常
        if (!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
        if (!path.endsWith(".txt"))
            throw new IOException("文件扩展名不为.txt");
    }
}

```

![image-20200826175147785](%E5%BC%82%E5%B8%B8.assets/image-20200826175147785.png)

```java
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;
import java.io.IOException;

public class TestThrowableMethods {
    public static void main(String[] args) {
        String path = "c:\\a.tx";
        try {
            getFile(path);
        } catch (IOException e) {
            //System.out.println( e.getMessage());//文件找不到
            /*System.out.println(e.toString());//java.io.FileNotFoundException: 文件找不到
            System.out.println(e);*/
            e.printStackTrace();
        }
        System.out.println("后续代码");
    }
    public static void getFile(String path) throws IOException {//交给方法调用者处理该异常
        if (!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
        if (!path.endsWith(".txt"))
            throw new IOException("文件扩展名不为.txt");
    }
}

```

![image-20200826175307667](%E5%BC%82%E5%B8%B8.assets/image-20200826175307667.png)

# finally 代码块

**finally**：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。

格式：

```java
try{
	可能产生异常的代码
}catch(定义一个异常的变量，用来接收try中抛出的异常对象){
	异常的处理逻辑，产生异常对象后，怎么处理异常对象
	一般会把异常信息记录到日志中
}//可以有多个catch。抛出多个异常时，catch多个异常
...
catch{
...
}finally{
	无论是否出现异常都会执行；
}
```

注意：

1. finally不能单独使用，必须和try-catch一起使用；
2. finally一般用于资源释放，无论程序是否发生异常，最后都要资源释放

未发生异常时：

```java
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;
import java.io.IOException;

public class TestFinally {
    public static void main(String[] args) {
        String path = "c:\\a.txt";
        try {
            getFile(path);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            System.out.println("资源释放");
        }
        System.out.println("后续代码");
    }
    public static void getFile(String path) throws IOException {//交给方法调用者处理该异常
        if (!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
        if (!path.endsWith(".txt"))
            throw new IOException("文件扩展名不为.txt");
        System.out.println("文件路径、扩展名都正确");
    }

}

```

![image-20200826180353880](%E5%BC%82%E5%B8%B8.assets/image-20200826180353880.png)

发生异常时：

```java
package space.buercheng.java.demo01;

import java.io.FileNotFoundException;
import java.io.IOException;

public class TestFinally {
    public static void main(String[] args) {
        String path = "c:\\a.tx";
        try {
            getFile(path);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            System.out.println("资源释放");
        }
        System.out.println("后续代码");
    }
    public static void getFile(String path) throws IOException {//交给方法调用者处理该异常
        if (!path.equals("c:\\a.txt"))
            throw new FileNotFoundException("文件找不到");
        if (!path.endsWith(".txt"))
            throw new IOException("文件扩展名不为.txt");
        System.out.println("文件路径、扩展名都正确");
    }

}

```

![image-20200826180446077](%E5%BC%82%E5%B8%B8.assets/image-20200826180446077.png)

# 异常的注意事项

## 多异常的捕获处理

1. 多个异常分别处理
2. 多个异常一次捕获，多次处理
3. 多个异常一次捕获，一次处理

```java
package space.buercheng.java.demo01;

import java.util.ArrayList;
import java.util.List;

public class TestMultiException {
    public static void main(String[] args) {
        /**
         * 1.多个异常分别处理
         * */
        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }

        try {
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");

    }
}

```

![image-20200826222540611](%E5%BC%82%E5%B8%B8.assets/image-20200826222540611.png)

```java
package space.buercheng.java.demo01;

import java.util.ArrayList;
import java.util.List;

public class TestMultiException {
    public static void main(String[] args) {
        /**
         * 1.多个异常分别处理
         * */
        /*try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }

        try {
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");*/

        /**
         * 2. 多个异常一次捕获，多次处理
         * **/
        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");

    }
}

```

一个try多个catch注意事项：

​				catch里面定义的异常变量如果有子父类关系，那么子类异常变量应该写在上面，否则会报错

eg:ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException

```java
package space.buercheng.java.demo01;

import java.util.ArrayList;
import java.util.List;

public class TestMultiException {
    public static void main(String[] args) {
        /**
         * 1.多个异常分别处理
         * */
        /*try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }

        try {
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");*/

        /**
         * 2. 多个异常一次捕获，多次处理
         * **/
        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");

    }
}

```

![image-20200826223516526](%E5%BC%82%E5%B8%B8.assets/image-20200826223516526.png)

```java
package space.buercheng.java.demo01;

import java.util.ArrayList;
import java.util.List;

public class TestMultiException {
    public static void main(String[] args) {
        /**
         * 1.多个异常分别处理
         * */
        /*try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }

        try {
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");*/

        /**
         * 2. 多个异常一次捕获，多次处理
         * **/
        /*try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");*/

        /**
         * 3.多个异常一次捕获一次处理
         * **/

        try {
            int[] arr = {1, 2, 3};
            //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch(IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");

    }
}

```

![image-20200826224336025](%E5%BC%82%E5%B8%B8.assets/image-20200826224336025.png)

直接catch(Exception e){}

```java
package space.buercheng.java.demo01;

import java.util.ArrayList;
import java.util.List;

public class TestMultiException {
    public static void main(String[] args) {
        /**
         * 1.多个异常分别处理
         * */
        /*try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }

        try {
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");*/

        /**
         * 2. 多个异常一次捕获，多次处理
         * **/
        /*try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }catch (IndexOutOfBoundsException e){
            System.out.println(e);
        }
        System.out.println("后续代码");*/

        /**
         * 3.多个异常一次捕获一次处理
         * **/

        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
            ArrayList<Integer> list = new ArrayList<>();
            list.get(1);//IndexOutOfBoundsException
        }catch(Exception e){
            System.out.println(e);
        }
        System.out.println("后续代码");

    }
}

```

## finally有return语句

如果finally有return语句，永远返回finally中的结果，避免该情况。

```java
package space.buercheng.java.demo01;

public class FinallyReturn {
    public static void main(String[] args) {
        int a = getA();
        System.out.println(a);
    }

    public static int getA(){
        int a = 10;
        try{
            return a;
        }catch (Exception e){

        }finally {
            a = 100;
            return a;
        }
    }
}

```

![image-20200826225532304](%E5%BC%82%E5%B8%B8.assets/image-20200826225532304.png)

## 子父类异常

* 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。
* 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生异常，只能捕获处理，不能声明抛出



# 自定义异常类

Java提供的异常类，不够我们使用，需要自己定义一些异常类。

格式：	

```
public class xxxException extends Exception/RuntimeException{
	添加一个空参数的构造方法；
	添加一个带异常信息的构造方法；（通过查看源代码得知，所有的异常类都有一个带异常信息的构造方法，且都调用了父类的带异常信息的构造方法，交给父类来处理异常信息）
}
```

注意：

1. 自定义异常类一般都是以Exception结尾，说明该类是一个异常类；

2. 自定义异常类，必须继承Exception或者RuntimeException

	​			继承Exception，那么自定义的异常类就是一个编译期异常，如果方法内部抛出了异常，就必须处理这个异常，要么throws，要么try-catch

	​			继承RuntimeException，那么自定义的异常类就是一个运行时异常，无需处理，交给虚拟机处理（中断处理）。