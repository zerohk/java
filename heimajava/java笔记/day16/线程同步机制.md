# 线程安全

多线程访问共享数据，会产生安全问题。

如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样
的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
我们通过一个案例，演示线程的安全问题：
电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个
(本场电影只能卖100张票)。
我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)

```java
package space.buercheng.java.demo01;
/**
 * 实现Runnable接口产生多线程
 * **/
public class MyThread implements Runnable{
    //多个线程共享的票源
    private int ticket = 100;
    @Override
    public void run() {
        //死循环
        while (true){
            //判断票是否存在，出票，ticket--
            if(ticket > 0) {
                //调用Thread.sleep提高产生安全问题的概率
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在出票，第" + ticket + "张");
                ticket--;
            }
        }
    }
}
```

```java
package space.buercheng.java.demo01;

public class ThreadSecurity01 {
    public static void main(String[] args) {
        //创建一个Runnable实现类对象
        MyThread run = new MyThread();
        //创建三个Thread对象，构造器参数传入Runnable实现类对象
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        //调用start方法，启动线程
        t0.start();
        t1.start();
        t2.start();

    }
}

```

![image-20200910170420335](%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.assets/image-20200910170420335.png)

![image-20200910170437953](%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.assets/image-20200910170437953.png)

由运行结果看到，产生了重复票，还有不存在的票，所以产生了线程安全问题

线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写
操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，
否则的话就可能影响线程安全

# 解决线程安全问题

## 同步代码块

格式：synchronized(锁对象){可能出现线程安全问题的代码/共享资源的线程}

注意事项：锁对象 可以是任意类型。多个线程对象 要使用同一把锁。

```java
package space.buercheng.java.demo02;

public class Synchronized implements Runnable{
    private int ticket = 100;
    //创建锁对象
    Object obj = new Object();
    @Override
    public void run() {
        while(true){
            synchronized (obj){
                if(ticket > 0){
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "正在出票，第" + ticket + "张");
                    ticket--;
                }
            }
        }
    }
}

```

```java
package space.buercheng.java.demo02;

public class TestSynchronized {
    public static void main(String[] args) {
        Synchronized run = new Synchronized();
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        t0.start();
        t1.start();
        t2.start();

    }
}

```

![image-20200910185359312](%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.assets/image-20200910185359312.png)

不再有重复票，也不再有错误票。

## 同步线程方法

### 普通同步方法

格式:修饰符 synchronized 返回值 方法名(参数列表){可能产生线程安全的代码}

```java
package space.buercheng.java.demo03;

public class SynchronizedMethod implements Runnable{
    private int ticket = 100;
    @Override
    public void run() {
        while(true){
            checkTicket();
        }
    }
    public synchronized void checkTicket(){
        if(ticket > 0){
            System.out.println(Thread.currentThread().getName() + "正在出票，第" +ticket + "张");
            ticket--;
        }
    }
}

```

```java
package space.buercheng.java.demo03;

public class MyThread {
    public static void main(String[] args) {
        SynchronizedMethod run = new SynchronizedMethod();
        Thread t0 = new Thread(run);
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        t0.start();
        t1.start();
        t2.start();

    }
}

```

### 静态同步方法

就是将普通同步方法加上static关键字，变成静态同步方法。

```java
package space.buercheng.java.demo04;

public class SynchronizedMethod implements Runnable{
    private static int ticket = 100;
    @Override
    public void run() {
        while(true){
            checkTicket();
        }
    }
    public static synchronized void checkTicket(){
        if(ticket > 0){
            System.out.println(Thread.currentThread().getName() + "正在出票，第" +ticket + "张");
            ticket--;
        }
    }
}

```

### 锁对象

对于非static方法,同步锁就是this。
对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。（反射）

```java
package space.buercheng.java.demo03;

public class Sync01 implements Runnable{
    private int ticket = 100;
    @Override
    public void run() {
        while(true){
            checkTicket();
        }
    }

    public void checkTicket(){
        synchronized (this){
            if(ticket > 0){
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在出票，第" +ticket + "张");
                ticket--;
            }
        }
    }
}

```

![image-20200910232308809](%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.assets/image-20200910232308809.png)

```java
package space.buercheng.java.demo04;

public class Sync01 implements Runnable{
    private static int ticket = 100;
    @Override
    public void run() {
        while(true){
            checkTicket();
        }
    }

    public static void checkTicket() {
        synchronized (Sync01.class) {
            if (ticket > 0) {
                System.out.println(Thread.currentThread().getName() + "正在出票，第" + ticket + "张");
                ticket--;
            }
        }
    }
}

```

## Lock锁

java.util.concurrent.locks.Lock （接口）机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,
同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。
Lock锁也称同步锁，加锁与释放锁方法化了，如下：
public void lock() :加同步锁。
public void unlock() :释放同步锁。

java.util.concurrent.locks.ReentrantLock实现了Lock接口。

使用步骤：

1. 在成员位置创建一个ReentrantLock对象；

2. 在可能出现线程安全问题的代码前面调用Lock接口中的lock方法获取锁；

3. 在可能出现线程安全问题的代码后面调用Lock接口中的unlock方法释放锁。

	```java
	package space.buercheng.java.demo05;
	
	import java.util.concurrent.locks.Lock;
	import java.util.concurrent.locks.ReentrantLock;
	
	public class LockSync implements Runnable{
	    //创建Lock对象
	    Lock lock = new ReentrantLock();
	    private int ticket = 100;
	    @Override
	    public void run() {
	        while(true){
	            try {
	                Thread.sleep(10);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	            //在可能出现线程安全问题的代码前调用Lock接口的lock方法获取锁
	            lock.lock();
	            if(ticket > 0){
	                System.out.println(Thread.currentThread().getName() + "正在出票，第" + ticket-- + "张票");
	            }
	            //在可能出现线程安全问题的代码后调用Lock接口的unlock方法释放锁
	            lock.unlock();
	        }
	    }
	}
	
	```

	

改进：

```java
package space.buercheng.java.demo05;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockSync implements Runnable{
    //创建Lock对象
    Lock lock = new ReentrantLock();
    private int ticket = 100;
    @Override
    public void run() {
        while(true){
            //在可能出现线程安全问题的代码前调用Lock接口的lock方法获取锁
            lock.lock();
            try {
                Thread.sleep(10);
                if(ticket > 0){
                    System.out.println(Thread.currentThread().getName() + "正在出票，第" + ticket-- + "张票");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                //在可能出现线程安全问题的代码后调用Lock接口的unlock方法释放锁
                lock.unlock();//无论程序是否出现异常，都释放锁，提高了程序的效率
            }
        }
    }
}

```

